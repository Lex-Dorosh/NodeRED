// ==UserScript==
// @name         GXO Groupwise - Close order (one click) v1.5
// @namespace    https://groupwise.cerepair.nl/
// @version      1.5
// @description  Close order one-click (stable): WD once + save once, exact cancel flow, targeted OK handling, no aggressive loops.
// @author       you
// @match        https://groupwise.cerepair.nl/*
// @run-at       document-end
// @grant        none
// ==/UserScript==

(function () {
  'use strict';

  const DEBUG = true;

  const STATE_KEY = 'gxo_close_order_flow_v1_5';
  const TTL_MS = 20 * 60 * 1000;

  const POLL_MS = 450;
  const MAX_POLLS_PER_STEP = 60; // ~27s per step

  const CLOSE_TEXT =
    'Deze order wordt gesloten zonder verdere verwerking.  Als u in de toekomst een reparatie nodig heeft, gelieve een nieuwe order aan te maken.';

  // What to pick in assistoption
  const ASSIST_VALUE = '11'; // Klant reageert niet.

  // OK popups we are allowed to auto-close (TARGETED only)
  const OK_PHRASES = [
    'is er inderdaad geen reparatie verricht', // confirm when setting Afgewikkeld
    'de order is geannuleerd',                 // after cancel
    'update geslaagd'                          // sometimes after save
  ];

  const STEP = {
    IDLE: 'idle',
    WD_SAVE: 'wdSave',
    SET_PREP: 'setPrep',
    CLICK_CANCEL: 'clickCancel',
    WAIT_ASSIST: 'waitAssist',
    SET_ASSIST: 'setAssist',
    WAIT_TECH: 'waitTech',
    SET_ADMIN: 'setAdmin',
    SET_AFG: 'setAfgewikkeld',
    WAIT_AFG: 'waitAfgewikkeld',
    DONE: 'done',
    HALTED: 'halted'
  };

  function log(...a) { if (DEBUG) console.log('[CloseOrder]', ...a); }

  // storage
  function sGet(k) { try { return sessionStorage.getItem(k); } catch { return null; } }
  function sSet(k, v) { try { sessionStorage.setItem(k, v); return true; } catch { return false; } }
  function sRemove(k) { try { sessionStorage.removeItem(k); } catch {} }

  function readState() {
    const raw = sGet(STATE_KEY);
    if (!raw) return null;
    try { return JSON.parse(raw); } catch { return null; }
  }
  function writeState(st) { sSet(STATE_KEY, JSON.stringify(st || {})); }

  function resetState() {
    sRemove(STATE_KEY);
    log('State reset.');
  }

  function isRepairPage() {
    return location.pathname.includes('edit.ashx') && location.search.includes('name=reparatie');
  }

  function getOrderIdFromUrl() {
    try {
      const u = new URL(location.href);
      const id = u.searchParams.get('item_id');
      return (id && /^\d+$/.test(id)) ? id : null;
    } catch { return null; }
  }

  function ensureFreshState() {
    const st = readState();
    if (!st) return;

    const now = Date.now();
    const age = now - (Number(st.ts) || 0);
    if (age > TTL_MS) {
      log('State stale -> reset.');
      resetState();
      return;
    }

    const cur = getOrderIdFromUrl();
    if (st.orderId && cur && st.orderId !== cur) {
      log('State from other order -> reset.');
      resetState();
    }
  }

  function setStep(step, poll = 0) {
    const st = readState() || {};
    st.orderId = getOrderIdFromUrl() || st.orderId || null;
    st.step = step;
    st.poll = poll;
    st.ts = Date.now();
    writeState(st);
    log('Step ->', step);
  }

  function halt(reason) {
    const st = readState() || {};
    st.step = STEP.HALTED;
    st.haltedReason = reason || 'Unknown';
    st.ts = Date.now();
    writeState(st);
    log('HALTED:', st.haltedReason);
    alert('Close order helper gestopt: ' + st.haltedReason + '\nGebruik ↺ of Ctrl+Alt+R om te resetten.');
  }

  // DOM helpers
  function norm(s) { return String(s || '').replace(/\s+/g, ' ').trim().toLowerCase(); }

  function triggerChange(el) {
    if (!el) return;
    try { el.dispatchEvent(new Event('change', { bubbles: true })); } catch {}
    try { if (typeof el.onchange === 'function') el.onchange(); } catch {}
  }

  function setValueRich(el, val, label) {
    if (!el) return false;
    const before = el.value;
    el.value = val;
    try { el.dispatchEvent(new Event('input', { bubbles: true })); } catch {}
    triggerChange(el);
    try { el.dispatchEvent(new Event('blur', { bubbles: true })); } catch {}
    log(`Set ${label}: "${before}" -> "${el.value}"`);
    return true;
  }

  function click(el, label) {
    if (!el) return false;
    log('Click:', label || (el.id || el.value || el.textContent || 'button'));
    try { el.click(); return true; } catch { return false; }
  }

  // controls (your known ids)
  function wdEl() { return document.getElementById('workdescription'); }
  function opslaanBtn() { return document.getElementById('opslaan'); }
  function statusSel() { return document.getElementById('lst_status'); }
  function assistSel() { return document.getElementById('assistoption'); }
  function cancelBtn() { return document.getElementById('btn_cancel'); }

  function currentStatusText() {
    const sel = statusSel();
    if (!sel || !sel.selectedOptions || !sel.selectedOptions[0]) return '';
    return (sel.selectedOptions[0].textContent || '').trim();
  }

  function isStatusIncludes(inc, excList = []) {
    const t = norm(currentStatusText());
    const i = norm(inc);
    if (!t.includes(i)) return false;
    for (const ex of excList) {
      if (t.includes(norm(ex))) return false;
    }
    return true;
  }

  function findStatusOption(includesText, excludes = []) {
    const sel = statusSel();
    if (!sel) return null;

    const inc = norm(includesText);
    const exs = (excludes || []).map(norm);
    const opts = Array.from(sel.options || []);

    return opts.find(o => {
      const t = norm(o.textContent);
      if (!t.includes(inc)) return false;
      for (const ex of exs) if (ex && t.includes(ex)) return false;
      return true;
    }) || null;
  }

  function setStatusByOption(opt) {
    const sel = statusSel();
    if (!sel || !opt) return false;

    if (String(sel.value) === String(opt.value)) {
      log('Status already selected:', (opt.textContent || '').trim(), '(value=' + opt.value + ')');
      return true;
    }

    sel.value = String(opt.value);
    triggerChange(sel); // page reloads
    log('Status set ->', (opt.textContent || '').trim(), '(value=' + opt.value + ') [will reload]');
    return true;
  }

  // JS popups: only confirm, keep alert closed (non-blocking)
  function installJsAutoOkOnce() {
    if (window.__closeorder_jsok_v15) return;
    window.__closeorder_jsok_v15 = true;

    const origAlert = window.alert ? window.alert.bind(window) : null;
    const origConfirm = window.confirm ? window.confirm.bind(window) : null;

    if (window.alert) {
      window.alert = function (msg) {
        log('Auto-close alert:', msg);
        return;
      };
    }
    if (window.confirm) {
      window.confirm = function (msg) {
        log('Auto-confirm:', msg);
        return true;
      };
    }

    window.__closeorder_jsok_orig_v15 = { origAlert, origConfirm };
    log('JS popup auto-OK installed.');
  }

  // Targeted DOM OK: click only if a known phrase is present somewhere visible-ish
  function hasAnyOkPhrase() {
    const bodyText = norm(document.body && document.body.innerText ? document.body.innerText : '');
    return OK_PHRASES.some(p => bodyText.includes(norm(p)));
  }

  function clickVisibleOkButtonOnce() {
    // only if phrase present
    if (!hasAnyOkPhrase()) return false;

    const candidates = Array.from(document.querySelectorAll('button, input[type="button"], input[type="submit"], a'))
      .filter(el => {
        const r = el.getBoundingClientRect ? el.getBoundingClientRect() : null;
        return r && r.width > 0 && r.height > 0;
      })
      .filter(el => {
        const t = norm(el.textContent);
        const v = norm(el.value);
        const s = (t + ' ' + v).trim();
        return s === 'ok' || s === 'oke' || s === 'ja' || s === 'yes';
      });

    if (!candidates.length) return false;
    log('Targeted DOM OK click:', candidates[0].textContent || candidates[0].value || 'OK');
    try { candidates[0].click(); return true; } catch { return false; }
  }

  // UI
  function injectUI() {
    let host = null;
    const finLegend = Array.from(document.querySelectorAll('fieldset > legend'))
      .find(l => norm(l.textContent) === 'financials');
    if (finLegend && finLegend.parentElement) host = finLegend.parentElement;

    if (!host) {
      const wd = wdEl();
      if (wd) host = wd.closest('fieldset') || wd.parentElement;
    }
    if (!host) return;
    if (host.querySelector('.closeorder-helper-bar')) return;

    const bar = document.createElement('div');
    bar.className = 'closeorder-helper-bar';
    bar.style.marginTop = '6px';
    bar.style.display = 'flex';
    bar.style.justifyContent = 'flex-end';
    bar.style.gap = '4px';
    bar.style.flexWrap = 'wrap';

    function styleBtn(btn) {
      btn.type = 'button';
      btn.className = 'button';
      btn.style.whiteSpace = 'nowrap';
      btn.style.fontSize = '9px';
      btn.style.padding = '2px 6px';
      btn.style.minHeight = '18px';
    }

    const btnClose = document.createElement('button');
    btnClose.textContent = 'Close order';
    styleBtn(btnClose);
    btnClose.title = 'Flow: Opdracht voorbereid -> Annuleren -> Klant reageert niet -> Technisch -> Administratief -> Afgewikkeld.';
    btnClose.addEventListener('click', () => startFlow());

    const btnReset = document.createElement('button');
    btnReset.textContent = '↺';
    styleBtn(btnReset);
    btnReset.style.width = '26px';
    btnReset.title = 'Reset (Ctrl+Alt+R)';
    btnReset.addEventListener('click', () => {
      resetState();
      alert('Close order helper gereset.');
    });

    bar.appendChild(btnClose);
    bar.appendChild(btnReset);
    host.appendChild(bar);
  }

  function startFlow() {
    const orderId = getOrderIdFromUrl();
    if (!orderId) {
      alert('Close order helper: kan geen item_id vinden in de URL.');
      return;
    }
    writeState({
      orderId,
      step: STEP.WD_SAVE,
      poll: 0,
      ts: Date.now(),
      wdWritten: false,
      wdSaved: false
    });
    log('Close flow started. orderId=', orderId, 'currentStatus=', currentStatusText() || '(unknown)');
    installJsAutoOkOnce();
    setTimeout(runOnce, 200);
  }

  function runOnce() {
    if (!isRepairPage()) return;

    ensureFreshState();
    const st = readState();
    if (!st) return;

    if (st.step === STEP.IDLE || st.step === STEP.DONE || st.step === STEP.HALTED) return;

    installJsAutoOkOnce();

    // click targeted DOM OK if it appears
    clickVisibleOkButtonOnce();

    const poll = Number(st.poll || 0);
    if (poll > MAX_POLLS_PER_STEP) {
      halt('Timeout step=' + st.step + ' status=' + (currentStatusText() || '(unknown)'));
      return;
    }

    function repoll(nextStepSame = true) {
      const st2 = readState() || st;
      st2.poll = nextStepSame ? (poll + 1) : 0;
      st2.ts = Date.now();
      writeState(st2);
      setTimeout(runOnce, POLL_MS);
    }

    switch (st.step) {
      case STEP.WD_SAVE: {
        // write WD once + save once
        if (!st.wdWritten) {
          const wd = wdEl();
          if (!wd) return repoll(true);
          setValueRich(wd, CLOSE_TEXT, 'workdescription(force-once)');
          st.wdWritten = true;
          st.ts = Date.now();
          writeState(st);
        }

        if (!st.wdSaved) {
          const save = opslaanBtn();
          if (save) click(save, 'Opslaan');
          st.wdSaved = true;
          st.ts = Date.now();
          writeState(st);
          // give backend a moment (some pages alert "update geslaagd")
          setTimeout(() => {
            setStep(STEP.SET_PREP, 0);
            runOnce();
          }, 600);
          return;
        }

        setStep(STEP.SET_PREP, 0);
        return repoll(false);
      }

      case STEP.SET_PREP: {
        const sel = statusSel();
        if (!sel) return repoll(true);
        const opt = findStatusOption('opdracht voorbereid', []);
        if (!opt) return repoll(true);

        setStatusByOption(opt);  // reload
        setStep(STEP.CLICK_CANCEL, 0);
        return; // stop on this page; next load continues
      }

      case STEP.CLICK_CANCEL: {
        const btn = cancelBtn();
        if (!btn) return repoll(true);
        click(btn, 'Annuleren order (#btn_cancel)');
        setStep(STEP.WAIT_ASSIST, 0);
        return repoll(false);
      }

      case STEP.WAIT_ASSIST: {
        if (!assistSel()) return repoll(true);
        setStep(STEP.SET_ASSIST, 0);
        return repoll(false);
      }

      case STEP.SET_ASSIST: {
        const sel = assistSel();
        if (!sel) return repoll(true);

        const opt = Array.from(sel.options || []).find(o => String(o.value) === ASSIST_VALUE);
        if (!opt) return repoll(true);

        sel.value = String(opt.value);
        triggerChange(sel); // this auto changes status to Technisch afgewikkeld and reloads
        log('Assist reason set ->', (opt.textContent || '').trim(), '(value=' + opt.value + ') [will reload]');
        setStep(STEP.WAIT_TECH, 0);
        return; // wait next load
      }

      case STEP.WAIT_TECH: {
        // must become Technisch afgewikkeld automatically
        if (!isStatusIncludes('technisch afgewikkeld')) return repoll(true);
        setStep(STEP.SET_ADMIN, 0);
        return repoll(false);
      }

      case STEP.SET_ADMIN: {
        const sel = statusSel();
        if (!sel) return repoll(true);

        const opt = findStatusOption('administratief afgewikkeld', []);
        if (!opt) return repoll(true);

        setStatusByOption(opt); // reload
        setStep(STEP.SET_AFG, 0);
        return;
      }

      case STEP.SET_AFG: {
        const sel = statusSel();
        if (!sel) return repoll(true);

        // choose Afgewikkeld but exclude Administratief
        const opt = findStatusOption('afgewikkeld', ['administratief']);
        if (!opt) return repoll(true);

        setStatusByOption(opt); // reload + confirm (JS confirm auto ok)
        setStep(STEP.WAIT_AFG, 0);
        return;
      }

      case STEP.WAIT_AFG: {
        // after confirm and reload, final status should be Afgewikkeld (not Administratief)
        if (!isStatusIncludes('afgewikkeld', ['administratief'])) return repoll(true);

        setStep(STEP.DONE, 0);
        log('Close flow DONE. status=', currentStatusText());
        alert('Close order helper: order afgesloten (Afgewikkeld).');
        return;
      }

      default:
        halt('Onbekende step: ' + st.step);
        return;
    }
  }

  function installResetHotkey() {
    const handler = (e) => {
      const key = (e.key || '').toLowerCase();
      if (e.ctrlKey && e.altKey && key === 'r') {
        e.preventDefault();
        resetState();
        try { alert('Close order helper: gereset.'); } catch {}
      }
    };
    window.addEventListener('keydown', handler, true);
    document.addEventListener('keydown', handler, true);
    try {
      if (window.top && window.top !== window) {
        window.top.addEventListener('keydown', handler, true);
        window.top.document.addEventListener('keydown', handler, true);
      }
    } catch {}
  }

  // BOOT
  window.addEventListener('load', () => {
    log('Loaded URL:', location.href);

    if (!isRepairPage()) {
      log('Not a repair page, nothing to do');
      return;
    }

    ensureFreshState();
    installResetHotkey();
    injectUI();

    // resume if active
    const st = readState();
    if (st && st.step && st.step !== STEP.IDLE && st.step !== STEP.DONE && st.step !== STEP.HALTED) {
      installJsAutoOkOnce();
      setTimeout(runOnce, 250);
    }
  });
})();
